Q1：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

答案：vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中。在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key => index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。

key的作用是为了在数据变化时强制更新组件，以避免 "原地复用" 带来的副作用。另外，某些情况下不带key可能性能更好，key的作用是为了在数据变化时强制更新组件，以避免 "原地复用" 带来的副作用。说到底，key的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。而带唯一key时每次更新都不能找到可复用的节点，不但要销毁和创建vnode，在DOM里添加移除节点对性能的影响更大。所以会才说"不带key可能性能更好"。

## 当 vue 正在使用 v-for 渲染的元素列表时，它默认使用 "就地更新" 策略，即如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。该默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出，而刻意依赖默认行为可以获取性能上的提升。默认模式只适用于渲染简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。

## 为每项提供一个唯一key，便于给 vue 一个提示，用来跟踪每个节点的身份，从而重用和重新排序现有元素

## key Vue 识别节点的一个通用机制

## key 字符串或数值类型的值

## key 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

## 为什么不建议用index作为key？ 因为index作为key，和不带key的效果是一样的。index作为key时，每个列表项的index在变更前后也是一样的，不管你数组的顺序怎么颠倒，index 都是 0, 1, 2 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作


## vue diff算法
- 进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom
- 也就是说，diff的过程就是调用patch函数，比较新旧节点，一边比较一边给真实的DOM打补丁
- 特点
  1. 比较只会在同层级进行，不会跨层级比较
  2. 在diff比较的过程中，循环从两边向中间比较
- 比较方式  整体策略：深度优先，同级比较